// THIS IS A GENERATED FILE. DO NOT EDIT THIS
/*
 * Copyright 2020 ZUP IT SERVICOS EM TECNOLOGIA E INOVACAO SA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<%
  require_relative 'Synthax/Types/enum_type.rb'
  
  require_relative 'Synthax/Attributes/list.rb'
  require_relative 'Synthax/Attributes/dictionary.rb'
  require_relative 'Templates/template_helper.rb'
  
  require_relative 'Models/Layout/Flex/flex_wrap.rb'
  require_relative 'Models/Action/action.rb'
  require_relative 'Models/ServerDriven/server_driven_component.rb'

  @tab = "    "
  @doubleTab = @tab + @tab
  @template_helper = TemplateHelper.new
  @template_helper.languageIdentifier = SupportedLanguages.new.swift
  @template_helper.defaultDeclarationType = TypeStruct.new

  def dictionary_variable_declaration(variable) 
    type_of_key = adaptTypeNameToSwiftSpecific(variable.type_of_key)
    type_of_value = adaptTypeNameToSwiftSpecific(variable.type_of_value)
    type_name = "[#{type_of_key}: #{type_of_value}]"
    type_name
  end

  def single_variable_declaration(variable)
    type_name = @template_helper.fetch_type(variable.type.name)
    type_name = adaptTypeNameToSwiftSpecific(type_name)
    type_name
  end

  def variable_type_declaration(variable)
    if variable.instance_of? Dictionary
      type_name = dictionary_variable_declaration(variable)
    else
      type_name = single_variable_declaration(variable)
    end
    type_name = variable.isBindable ? "Expression<#{type_name}>" : type_name
    type_name = variable.class == List ? "[#{type_name}]" : type_name
    type_name = variable.isOptional ? type_name + "?" : type_name
    type_name
  end
  
  def handleTypeNameForInitMethod(variable)
    output = variable_type_declaration(variable)
    if variable.isOptional && variable.defaultValue == ''
      output += " = nil"
    elsif variable.defaultValue != ''
      output += " = #{variable.defaultValue}"
    end
    output
  end

  def handleInheritance(synthax_type)
    output = synthax_type.inheritFrom.size == 0 ? "" : ": "
    counter = 0
    for inherit in synthax_type.inheritFrom
      adaptedType = adaptTypeNameToSwiftSpecific(inherit.synthax_type.name)
      output += adaptedType
      output = synthax_type.inheritFrom.size - 1 != counter ? output + ", " : output
      counter += 1
    end
    output
  end

  def casesForEnum(objectType)
    output = "\n"
    for variable in objectType.synthax_type.variables
      output += "#{@tab}case #{snakeToCamelCase(variable.name)} = \"#{variable.name}\""
      output += "\n"
    end
    output
  end

  def snakeToCamelCase(string) 
    result = string.split('_').map{|e| e.capitalize}.join
    result[0] = result[0].downcase
    result
  end

  # TODO: refactor this with more methods
  def declarePropertiesForCommonObject(objectType)
    if objectType.synthax_type.variables.length == 0 
      return ""
    end
    output = "\n"
    for variable in objectType.synthax_type.variables
      if variable.comment != nil
        commentReplaced = variable.comment.gsub("\n", "\n#{@tab}/// ")
        output += "#{@tab}/// #{commentReplaced}\n"
      end
      # mutableKey = variable.isMutable || @template_helper.is_interface_or_abstract(objectType) ? "var" : "let"
      variable_accessor = !@template_helper.is_interface_or_abstract(objectType) ? "#{variable.accessor} " : ""
      output += "#{@tab}#{variable_accessor}var #{variable.name}: #{variable_type_declaration(variable)}"
      if @template_helper.is_interface_or_abstract(objectType)
        output += " { get #{variable.isMutable ? "set " : ""}}"
      end
      output += "\n"
    end

    for inherit in objectType.synthax_type.inheritFrom
      for variable in inherit.synthax_type.variables
        if variable.comment != nil
          commentReplaced = variable.comment.gsub("\n", "\n#{@tab}/// ")
          output += "#{@tab}/// #{commentReplaced}\n"
        end
        # mutableKey = variable.isMutable || @template_helper.is_interface_or_abstract(objectType) ? "var" : "let"
        variable_accessor = !@template_helper.is_interface_or_abstract(objectType) ? "#{variable.accessor} " : ""
        output += "#{@tab}#{variable_accessor}var #{variable.name}: #{variable_type_declaration(variable)}\n"
      end
    end

    output
  end

  def initForCommonObject(objectType)
    output = "\n"
    if objectType.synthax_type.variables.length == 0 || 
      @template_helper.is_interface(objectType) ||
      @template_helper.is_abstract(objectType)
      return ""
    end
    output += "#{@tab}#{objectType.synthax_type.accessor} init(\n"
    counter = 0
    for variable in objectType.synthax_type.variables
      output += "#{counter > 0 ? ",\n" : ""}#{@doubleTab}#{variable.name}: #{handleTypeNameForInitMethod(variable)}"
      counter += 1
    end
    for inherit in objectType.synthax_type.inheritFrom
      for variable in inherit.synthax_type.variables
        output += "#{counter > 0 ? ",\n" : ""}#{@doubleTab}#{variable.name}: #{handleTypeNameForInitMethod(variable)}"
        counter += 1
      end
    end
    
    output += "\n#{@tab}) {\n"

    def handleVariablesAssignment(variables)
      output = ""
      for variable in variables
        output += "#{@doubleTab}self.#{variable.name} = #{variable.name}\n"
      end
      output
    end
    output += handleVariablesAssignment(objectType.synthax_type.variables)
    for inherit in objectType.synthax_type.inheritFrom
      output += handleVariablesAssignment(inherit.synthax_type.variables)
    end

    output += "#{@tab}}\n"
    output
  end

  def fullDeclaration(objectType)
    isEnumDeclaration = @template_helper.is_enum(objectType)
    typeKind = @template_helper.fetch_built_in_type_declaration(objectType.synthax_type.type)
    commentReplaced = objectType.synthax_type.comment.gsub("\n", "\n/// ")
    output = objectType.synthax_type.comment != nil ? "/// #{commentReplaced}\n" : ""
    typeName = adaptTypeNameToSwiftSpecific(objectType.synthax_type.name)
    output += "#{objectType.synthax_type.accessor} #{typeKind} #{typeName}#{handleInheritance(objectType.synthax_type)} {\n"
    if isEnumDeclaration
      output += casesForEnum(objectType)
    else
      output += declarePropertiesForCommonObject(objectType)
      output += initForCommonObject(objectType)
    end

    output = handleInnerTypes(objectType.synthax_type.sameFileTypes, output)

    output += "\n}\n"

    output = handleSameFileTypes(objectType.synthax_type.sameFileTypes, output)

    output

  end

  def handleInnerTypes(objectTypes, input, paddingMultiplier = 1)
    output = input
    for objectType in objectTypes
      # Ignoring Size, EdgeValue and CornerRadius for handling as same file type
      next if objectType.name.eql?(Size.new.name) || 
        objectType.name.eql?(EdgeValue.new.name) || 
        objectType.name.eql?(CornerRadius.new.name)
        
      preRun(objectType)
      aux = "\n#{fullDeclaration(objectType)}"
      output += @template_helper.add_padding(@tab, paddingMultiplier, aux)
      possibleNestedTypes = objectType.synthax_type.sameFileTypes
      if possibleNestedTypes.size > 0
        handleInnerTypes(objectType.synthax_type.sameFileTypes, output, paddingMultiplier + 1)
      end
    end
    output
  end

  def handleSameFileTypes(objectTypes, input)
    output = input
    for objectType in objectTypes
      # Used only in for EdgeValue, Size and CornerRadius
      if objectType.name.eql?(Size.new.name) || 
        objectType.name.eql?(EdgeValue.new.name) || 
        objectType.name.eql?(CornerRadius.new.name)

        preRun(objectType)
        output += "\n#{fullDeclaration(objectType)}"
      end
    end
    output
  end

  # Everything that is inside this method indicates something that need to be done only for swift
  def preRun(object_type)

    # General rules
    if @template_helper.is_widget(object_type) &&
      !@template_helper.is_interface_or_abstract(object_type)
      object_type.synthax_type.variables.append(
        Field.new(:name => "widgetProperties", :type => SwiftCustom.new("WidgetProperties"), :defaultValue => "WidgetProperties()")
      )
    end

    if @template_helper.is_enum(object_type)
      object_type.synthax_type.inheritFrom.append(SwiftCustom.new("String"))
    end

    if @template_helper.is_server_driven_component(object_type) && 
      !@template_helper.is_interface_or_abstract(object_type)
      object_type.synthax_type.inheritFrom.append(SwiftCustom.new("AutoDecodable"))
    elsif !@template_helper.is_interface_or_abstract(object_type)
      object_type.synthax_type.inheritFrom.append(SwiftCustom.new("Decodable"))
    end

    # Especific Rules
    if object_type.name.eql?(Style.new.name) || 
      object_type.name.eql?(Flex.new.name) || 
      object_type.name.eql?(Size.new.name) || 
      object_type.name.eql?(EdgeValue.new.name) 

      object_type.synthax_type.type = BuiltInType.new(:name => "class")
      object_type.synthax_type.inheritFrom.append(SwiftCustom.new("AutoEquatable"))
    end

    if object_type.name.eql?(Accessibility.new.name) ||
      object_type.name.eql?(CornerRadius.new.name) ||
      object_type.name.eql?(UnitValue.new.name)

      object_type.synthax_type.inheritFrom.append(SwiftCustom.new("Equatable"))
    end

    if object_type.name.eql?(ClickEvent.new.name)
      object_type.synthax_type.inheritFrom.pop
      object_type.synthax_type.inheritFrom.append(SwiftCustom.new("AnalyticsEvent"))
    end
  end

  ## CAUTION: the following methods will be deleted
  def adaptTypeNameToSwiftSpecific(typeName)
    if typeName.eql?(FlexWrap.new.name)
      "Wrap"
    elsif typeName.eql?(ContextComponent.new.name)
      "HasContext"
    elsif typeName.eql?("ContextData")
      "DynamicObject"
    elsif typeName.eql?(SwiftCustom.new("WidgetProperties").name)
      "WidgetProperties"
    else
      typeName
    end
  end

  class SwiftCustom < BaseComponent
    def initialize(name)
      synthax_type = BuiltInType.new(
        :type => TypeInterface.new,
        :name => name
      )
      super(synthax_type)
    end
  end

-%>

<%=
preRun(objectType)
fullDeclaration(objectType) 
%>