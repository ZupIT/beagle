// THIS IS A GENERATED FILE. DO NOT EDIT THIS
/*
 * Copyright 2020 ZUP IT SERVICOS EM TECNOLOGIA E INOVACAO SA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<%
  require_relative 'Synthax/Types/enum_type.rb'
  require_relative 'Synthax/Types/type_to_string.rb'
  require_relative 'Synthax/Attributes/list.rb'
  require_relative 'Synthax/Attributes/dictionary.rb'
  require_relative 'Templates/template_helper.rb'
  
  require_relative 'Models/Layout/Flex/flex_wrap.rb'
  require_relative 'Models/Action/action.rb'
  require_relative 'Models/ServerDriven/server_driven_component.rb'

  @tab = "    "
  @doubleTab = @tab + @tab
  @template_helper = TemplateHelper.new
  @template_helper.languageIdentifier = SupportedLanguages.new.swift
  @template_helper.defaultDeclarationType = "struct"

  def dictionary_variable_declaration(variable) 
    type_of_key = adaptTypeNameToSwiftSpecific(variable.type_of_key)
    type_of_value = adaptTypeNameToSwiftSpecific(variable.type_of_value)
    type_name = "[#{type_of_key}: #{type_of_value}]"
    type_name
  end

  def single_variable_declaration(variable)
    type_name = @template_helper.fetch_type(variable.typeName)
    type_name = adaptTypeNameToSwiftSpecific(type_name)
    type_name
  end

  def variable_type_declaration(variable)
    if variable.instance_of? Dictionary
      type_name = dictionary_variable_declaration(variable)
    else
      type_name = single_variable_declaration(variable)
    end
    type_name = variable.isBindable ? "Expression<#{type_name}>" : type_name
    type_name = variable.class == List ? "[#{type_name}]" : type_name
    type_name = variable.isOptional ? type_name + "?" : type_name
    type_name
  end
  
  def handleTypeNameForInitMethod(variable)
    output = variable_type_declaration(variable)
    if variable.isOptional && variable.defaultValue == ''
      output += " = nil"
    elsif variable.defaultValue != ''
      output += " = #{variable.defaultValue}"
    end
    output
  end

  def handleInheritance(synthax_type)
    output = synthax_type.inheritFrom.size == 0 ? "" : ": "
    counter = 0
    for inherit in synthax_type.inheritFrom
      adaptedType = adaptTypeNameToSwiftSpecific(inherit.synthax_type.name)
      output += adaptedType
      output = synthax_type.inheritFrom.size - 1 != counter ? output + ", " : output
      counter += 1
    end
    output
  end

  def casesForEnum(objectType)
    output = "\n"
    for variable in objectType.synthax_type.variables
      output += "#{@tab}case #{snakeToCamelCase(variable.name)} = \"#{variable.name}\""
      output += "\n"
    end
    output
  end

  def snakeToCamelCase(string) 
    result = string.split('_').map{|e| e.capitalize}.join
    result[0] = result[0].downcase
    result
  end

  def declarePropertiesForCommonObject(objectType)
    if objectType.synthax_type.variables.length == 0 
      return ""
    end
    output = "\n"
    for variable in objectType.synthax_type.variables
      output += variable.comment != nil ? "#{@tab}/// #{variable.comment}\n" : ""
      output += "#{@tab}#{variable.accessor} var #{variable.name}: #{variable_type_declaration(variable)}\n"
    end
    for inherit in objectType.synthax_type.inheritFrom
      for variable in inherit.synthax_type.variables
        output += variable.comment != nil ? "#{@tab}/// #{variable.comment}\n" : ""
        output += "#{@tab}#{variable.accessor} var #{variable.name}: #{variable_type_declaration(variable)}\n"
      end
    end
    output += "\n"

    output
  end

  def initForCommonObject(objectType)
    if objectType.synthax_type.variables.length == 0 || 
      objectType.synthax_type.type == TypesToString.interface ||
      objectType.synthax_type.type == TypesToString.abstract
      return ""
    end
    output = "#{@tab}#{objectType.synthax_type.accessor} init(\n"
    counter = 0
    for variable in objectType.synthax_type.variables
      output += "#{counter > 0 ? ",\n" : ""}#{@doubleTab}#{variable.name}: #{handleTypeNameForInitMethod(variable)}"
      counter += 1
    end
    for inherit in objectType.synthax_type.inheritFrom
      for variable in inherit.synthax_type.variables
        output += "#{counter > 0 ? ",\n" : ""}#{@doubleTab}#{variable.name}: #{handleTypeNameForInitMethod(variable)}"
        counter += 1
      end
    end
    
    output += "\n#{@tab}) {\n"

    def handleVariablesAssignment(variables)
      output = ""
      for variable in variables
        output += "#{@doubleTab}self.#{variable.name} = #{variable.name}\n"
      end
      output
    end
    output += handleVariablesAssignment(objectType.synthax_type.variables)
    for inherit in objectType.synthax_type.inheritFrom
      output += handleVariablesAssignment(inherit.synthax_type.variables)
    end

    output += "#{@tab}}\n"
    output
  end

  def fullDeclaration(objectType)
    isEnumDeclaration = @template_helper.is_enum(objectType)
    typeKind = @template_helper.fetch_built_in_type_declaration(objectType.synthax_type.type)
    output = objectType.synthax_type.comment != nil ? "/// #{objectType.synthax_type.comment}\n" : ""
    typeName = adaptTypeNameToSwiftSpecific(objectType.synthax_type.name)
    output += "#{objectType.synthax_type.accessor} #{typeKind} #{typeName}#{handleInheritance(objectType.synthax_type)} {\n"
    if isEnumDeclaration
      output += casesForEnum(objectType)
    else
      output += declarePropertiesForCommonObject(objectType)
      output += initForCommonObject(objectType)
    end

    output = handleInnerTypes(objectType.synthax_type.sameFileTypes, output)

    output += "\n}\n"
    output

  end

  def handleInnerTypes(objectTypes, input, paddingMultiplier = 1)
    output = input
    for objectType in objectTypes
      preRun(objectType)
      aux = "\n#{fullDeclaration(objectType)}"
      output += @template_helper.add_padding(@tab, paddingMultiplier, aux)
      possibleNestedTypes = objectType.synthax_type.sameFileTypes
      if possibleNestedTypes.size > 0
        handleInnerTypes(objectType.synthax_type.sameFileTypes, output, paddingMultiplier + 1)
      end
    end
    output
  end

  # Everything that is inside this method indicates something that need to be done only for swift
  def preRun(object_type)
    if @template_helper.is_widget(object_type)
      object_type.synthax_type.variables.append(
        Field.new(:name => "widgetProperties", :typeName => "WidgetProperties", :defaultValue => "WidgetProperties()")
      )
      object_type.synthax_type.inheritFrom.append(SwiftCustom.new("AutoDecodable"))
    elsif @template_helper.is_server_driven_component(object_type)
      object_type.synthax_type.inheritFrom.append(SwiftCustom.new("AutoDecodable"))
    elsif [Alert.new.name, AddChildren.new.name, Confirm.new.name, SendRequest.new.name, Condition.new.name].include? object_type.synthax_type.name
      object_type.synthax_type.inheritFrom.append(SwiftCustom.new("AutoDecodable"))
    elsif ![Screen.new.name].include? object_type.synthax_type.name
      object_type.synthax_type.inheritFrom.append(SwiftCustom.new("Decodable"))
    end
  
    if [UnitValue.new.name, SafeArea.new.name].include? object_type.synthax_type.name
      object_type.synthax_type.inheritFrom.append(SwiftCustom.new("Equatable"))
    end

    if [Flex.new.name, EdgeValue.new.name, Size.new.name, Style.new.name].include? object_type.synthax_type.name
      object_type.synthax_type.type = "class"
      object_type.synthax_type.inheritFrom.append(SwiftCustom.new("AutoEquatable"))
    end

    if [CornerRadius.new.name].include? object_type.synthax_type.name
      object_type.synthax_type.inheritFrom.append(SwiftCustom.new("AutoEquatable"))
    end

    if [Alignment.new.name].include? object_type.synthax_type.name
      object_type.synthax_type.inheritFrom.append(SwiftCustom.new("CaseIterable"))
    end

  end

  ## CAUTION: the following methods will be deleted
  def adaptTypeNameToSwiftSpecific(typeName)
    if typeName.eql?(FlexWrap.new.name)
      "Wrap"
    elsif typeName.eql?(ContextComponent.new.name)
      "HasContext"
    elsif typeName.eql?("ContextData")
      "DynamicObject"
    else
      typeName
    end
  end

  class SwiftCustom < BaseComponent
    def initialize(name)
      synthax_type = BuiltInType.new(
        :type => TypesToString.interface,
        :name => name
      )
      super(synthax_type)
    end
  end

-%>

<%=
preRun(objectType)
fullDeclaration(objectType) 
%>