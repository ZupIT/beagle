###
###  Android
###

platform :android do

  desc "Pull Request verification"
  lane :pull_request_verification do
    gradle(project_dir: "android", task: "detekt lintDebug jacocoTestReport")
    gradle(project_dir: "android", task: "sample:assembleDebug sample:assembleDebugAndroidTest")
    run_codecov(platform: 'android')
  end

end

###
###  Common (Android and Backend)
###

platform :common do

  desc "Publish remote new version"
  lane :remote_publish do
    gradle(task: "build")
    gradle(task: "publish")
  end

   desc "Publish local new version"
    lane :local_publish do
      gradle(task: "build")
      gradle(task: "publishToMavenLocal")
    end

end

###
###  iOS
###

platform :ios do

  desc "Pull Request verification"
  lane :pull_request_verification do
    xcversion(version: "~> 11.5.0")
    iOSSwiftLint
    scan(
      workspace: "iOS/Beagle.xcworkspace/",
      scheme: "All",
      device: "iPhone 11"
    )
    run_codecov(platform: 'ios')
  end

  desc "Run iOS SwiftLint"
  private_lane :iOSSwiftLint do
    swiftlint(
    mode: :lint,      # SwiftLint mode: :lint (default) or :autocorrect
    ignore_exit_status: true    # Allow fastlane to continue even if SwiftLint returns a non-zero exit status
  )
  end

  desc "Updates versions on Podspec"
  lane :release do
    version_bump_podspec(path: "Beagle.podspec", version_number: last_git_tag)
    version_bump_podspec(path: "BeagleSchema.podspec", version_number: last_git_tag)
    pod_push(path: "BeagleSchema.podspec", allow_warnings: true)
    pod_push(path: "Beagle.podspec", allow_warnings: true)
  end

end

desc "Publish new release based on last two tags"
lane :deploy do
  sh "git fetch"
  pattern = "*"
  if ENV["TAG_NAME"].index("-") # Hotfix
    tagName = ENV["TAG_NAME"].split("/").last
    platformHotfix = tagName.split("-").last
    pattern = "*-#{platformHotfix}"
    sh "git checkout #{tagName}"
  end

  ENV["VERSION_DEPLOY"] = last_git_tag(pattern: pattern)
  if platformHotfix == "ios"
    puts "iOS Hotfix release"
    sh "fastlane ios release"
  elsif platformHotfix == "android"
    puts "Android Hotfix release"
    sh "fastlane common remote_publish"
  elsif platformHotfix == "backend"
    puts "Backend Hotfix release"
    sh "fastlane common remote_publish"
  else
    puts "Normal Release"
    sh "fastlane common remote_publish"
    sh "fastlane ios release"
  end

  releaseNotes = release_notes
  sh "bash ./delete_release.sh"
  set_github_release(
    repository_name: "ZupIT/beagle",
    api_token: ENV["REPO_TOKEN"],
    name: ENV["VERSION_DEPLOY"],
    tag_name: ENV["VERSION_DEPLOY"],
    description: releaseNotes,
    commitish: tagName
  )
end

lane :run_danger do |options|
   danger_id = options[:danger_id] || lane_context[SharedValues::PLATFORM_NAME].to_s
   danger_file_path = options[:danger_file_path] || lane_context[SharedValues::PLATFORM_NAME].to_s
   danger(
     danger_id: danger_id,
     dangerfile: "danger/#{danger_file_path}/Dangerfile",
     github_api_token: ENV["GITHUB_TOKEN"],
     verbose: true
    )
end

###
###  Backend
###

platform :backend do

  desc "Pull Request verification"
  lane :pull_request_verification do
    gradle(project_dir: "backend", task: "detekt")
    gradle(project_dir: "backend", tasks:
        [
          "assemble",
          "jacocoTestReport",
        ]
    )
    run_codecov(platform: 'backend')
  end

  desc "Sync Spring BFF sample to Micronaut BFF sample"
  lane :sync_to_micronaut do
    sh "./sync-to-micronaut.sh"
    sh "./git_commit.sh 'Synced Spring BFF sample to Micronaut BFF sample.' '../backend/sample/micronaut'"
    push_to_git_remote
  end

  desc "Sync Micronaut BFF sample to Spring BFF sample"
  lane :sync_to_spring do
    sh "./sync-to-spring.sh"
    sh "./git_commit.sh 'Synced Micronaut BFF sample to Spring BFF sample.' '../backend/sample/spring'"
    push_to_git_remote
  end

end

desc "Generate release notes"
private_lane :release_notes do
  get_previous_tag = lastExpectedVersion(newVersion:ENV["VERSION_DEPLOY"])
  tagHashes = sh "git show-ref -s #{get_previous_tag}"

  lane_context[SharedValues::RELEASE_ANALYZED] = true
  lane_context[SharedValues::RELEASE_LAST_TAG_HASH] = tagHashes.split("\n").last
  lane_context[SharedValues::RELEASE_NEXT_VERSION] = ENV["TAG_NAME"]
  lane_context[SharedValues::CONVENTIONAL_CHANGELOG_ACTION_FORMAT_PATTERN] = "(feat|fix|refactor|perf|chore|test|docs|no_type)(:)()(.*)"
  changelog = conventional_changelog(display_title: false, display_links: false)
  changelog = changelog.gsub("**::**  ", "")
  "\nRelease notes #{ ENV["VERSION_DEPLOY"] }
   \nChanges:
   \n#{changelog}"
end

private_lane :run_codecov do |options|
  codecov = ENV["CODECOV_TOKEN"]
  if !(codecov.nil? || codecov.empty?)
     commit_hash = last_git_commit[:commit_hash]
     codecov_reporter(token: codecov, flags: "-F #{options[:platform]} -C #{commit_hash}")
  end
end

private_lane :danger_token_available? do
  danger = ENV["GITHUB_TOKEN"]
  !(danger.nil? || danger.empty?)
end

after_all do |lane, options|
   if lane == :pull_request_verification
       if danger_token_available?
         run_danger
       end
    end
end

error do |lane, exception, options|
  if lane == :pull_request_verification
     if danger_token_available?
       run_danger
     end
  end
end

lane :lastExpectedVersion do |params|
  platform = params[:newVersion].split("-")
  releaseNumberArray = platform.first.split(".")
  lastVersion = ""
  calculated = false
  for number in releaseNumberArray.reverse()
    intNumber = number.to_i
    if intNumber != 0 && !calculated
      intNumber -= 1
      calculated = true
    end
    lastVersion = ".#{intNumber}" + lastVersion
  end
  lastVersion[0] = ""

  version = ""
  if platform.length > 1
    version = "#{lastVersion}-#{platform[1]}"
  else
    version = lastVersion
  end
  "#{version}"
end